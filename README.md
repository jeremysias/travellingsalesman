travellingsalesman
==================

Solving the problem of finding the shortest path while visiting all points on a map and then returning to the start.

The Travelling Salesman Problem
The algorithm I chose was based on the “Cheapest Link” algorithm, found at http://www.people.vcu.edu/~gasmerom/MAT131/hamilton.html
Synopsis:
The idea is that you start with the smallest edge and continue to choose the next smallest valid edge and so on until you have the same number of edges as there were vertexes in the original array.  In order to determine whether an edge is valid there are two criteria that must be met:
1.	The edge may not have a vertex which has three edges.
2.	The edge must not close a circuit until the final edge.
On the final selection we lift the second criteria and close the circuit.  If done correctly then there will be one edge which has two points that have only been used once.  This will be the final edge.  The upside to this algorithm is that the tour will mostly contain the smallest edges possible.  The downside is that there is a good chance that the last few edges may be much larger than the others.
The “Cheapest Link” algorithm is a good start, but I wanted to take it further.  The first thing I realized when experimenting with this problem was that choosing all of the shortest edges does not generally produce the shortest tour.  Sometimes an edge needs to be skipped in order to for its vertexes to be available later in the selection process.  The question is where to search for the right edge to exclude in order to produce the best result.  The most optimal solution would test each edge, but this is not an efficient method.  I found that most of the best results came from testing the smallest 10% or less.  Often the same results would be found by testing the smallest 5% or even 1%.  I set up the program so that it varies this range depending on the size of the input.  If we have 15,000 vertexes then there are about 100,000,000 possible edges, which takes about 30 seconds/round. If we test 1% of possible exclusions then that would mean testing 1,000,000 scenarios.  At 30 seconds per round this would take about 1 year to complete.
After finding the best exclusion I still felt that I could take it further.  I wanted to come up with a combination of the best 10 exclusions, but searching for all combinations would increase the current running time by a power of 10.  So instead of searching all possible combinations, the algorithm saves the best exclusion from the previous round, and uses it as an exclusion for the next round, and then the best result from the 2nd round is also stored for the 3rd round and so on.  This is the part of the program where dynamic programming comes into play.  Instead of increasing the time by a power of 10, it only multiplies the amount of time by ten.  I had originally thought that if I were to find a best result in the first 10%, then the next exclusion should come in the next 10%, and so on.  However, that was not the case.  I found that most of the best exclusions came early in the sorted array, so each round begins its search at zero.

Implementation:
The first challenge, after reading the input into a useable array, Point[n](running time: 2n by the method used), is to find all possible edges.  To do this, I created an object Edge which has Point A,  Point B, and  distance. The first n edges have Point[0] as Point A and Points[1...n] as Point B, the next n edges have Point[1] as Point A and Points[2...n] as Point B, and the distance is calculated by sqrt((Ax – Bx)^2 + (Ay – By)^2).  This portion has running time: theta(n^2 - n) /2 
The next step is to sort all edges in ascending order.  At first, I created a merge sort function.  It worked fine for the normal size arrays, but with the 15000 points array, which ends up creating an Edge array of over 110,000,000, the array ate up all the memory and was taking over 10 hours to sort.  I figured I needed a better solution, so I borrowed and modified a Quick Sort program which I found at http://www.vogella.com/articles/JavaAlgorithmsQuicksort/article.html It requires much less memory and sorts the 110 million edge array in 63 seconds. If k = the Edge length of (n^2 – n)/2 then the Quicksort time is (k * log k)
After sorting, the next step was to choose the edges based on the criteria described in the synopsis.  Determining the first criteria is a simple matter of giving the Point object an integer that counts how many times the Point has been used and then ignoring the Edge if either Point has been used twice.  Determining whether the edge closes a circuit is much more complicated.  What I did was give every Point a path-Number so that I could quickly check which path a point was in.  I also created an array of arrays of integers to act as paths, and in the edge selection process I added several checks:  If neither Point is in a path, create a new path.  If only one Point is in a path, add the other point to the path.  If both points are in a path, check their path-Numbers.  If the path-Numbers are equal then skip the Edge.  If the path-Numbers are not equal then combine the paths and update the path-Numbers for each number added.  The final edge is found separately with only the first criteria as a restriction.  The selection process has a lower bound of n, and an upper bound of k.
The selection process is wrapped in two adjustable loops with several arrays and variables(which I made into array[1] in order to use it as a pointer in Java) that keep track of the best solution, the ID of the best exclusion for each round, and several other factors.  A sample set of loops would run 10 rounds of 1000 selection processes in order to find the best combination of exclusions.  This makes the entire selection process Omega(10,000(n)) and O(10,000(k)).
The final step is to organize the best array of Edges into a tour.  The tour starts with Point A of Edge[0].  Edge[1] is then found by finding and Edge such that Point(A or B) == Point B of Edge[0], and so on until the tour returns to the start.  This step has a lower bound of n and an upper bound of k since it utilizes a for loop of (0 – n) with a  while loop inside that terminates when each edge is found.
Total running time with 10 rounds of 1000 selections :
O(2n + (n^2-n) + (n^2-n) * log (n^2-n) + 10,000(n^2-n))		
Omega(3n + ((n^2-n)/2) + + (n^2-n) * log (n^2-n) + 10,000(n))
